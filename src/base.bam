-- just install a better name for the functions and tables
ScriptArgs = _bam_scriptargs
Execute = os.execute

--[[@GROUP Common @END]]--

--[[@FUNCTION
	Tells bam what version this script is written for. It will either
	make sure that it behaves like that version or print out an error.
	
	{{{{
	CheckVersion("0.1.0")
	}}}}
@END]]--
function CheckVersion(version)
	if version == _bam_version then
	else
		error("this file for version "..version..".x of bam. you are running ".._bam_version..".x.")
	end
end

--[[@FUNCTION
	Flatterns a tree of tables
@END]]--
function FlatternTable(varargtable)
	function flattern(collection, varargtable)
		for i,v in ipairs(varargtable) do
			if type(v) == type({}) then
				flattern(collection, v)
			elseif type(v) == type("") then
				table.insert(collection, v)
			end		
		end
	end

	local inputs = {}
	flattern(inputs, varargtable)
	return inputs
end

--[[@FUNCTION
	Inserts all fieds in source table into target table
@END]]--
function MergeIntoTable(target, source)
	for k,v in ipairs(source) do
		table.insert(target, v)
	end
	return taget
end

--[[@GROUP Path Manipulation @END]]--

--[[@FUNCTION Path(str)
	Normalizes the path in ^str^ by removing ".." and "." from it

	{{{{
	Path("test/./path/../file.name.ext") -- Returns "test/file.name.ext"
	}}}}
@END]]--
Path = bam_path_fix

-- [TODO: Should be in C]
--[[@FUNCTION
	Returns the everthing except the extention in the path.

	{{{{
	Path("test/path/file.name.ext") -- Returns "test/path/file.name"<br/>
	Path("test/path/file.name") -- Returns "test/path/file"<br/>
	Path("test/path/file") -- Returns "test/path/file"
	}}}}
@END]]--
function PathBase(s)
	local e = PathFileExt(s)
	if e == "" then
		return s
	end
	
	return string.sub(s,1,string.len(s)-string.len(PathFileExt(s))-1)
end

--[[@FUNCTION PathFilename(str)
	Returns the filename of the path in ^str^.

	{{{{
	PathFilename("test/path/file.name.ext") -- Returns "file.name.ext"
	}}}}
@END]]--
PathFilename = bam_path_filename

--[[@FUNCTION PathFileExt(str)
	Returns the extension of the filename in ^str^.
	
	{{{{
	PathFileExt("test/path/file.name.ext") -- Returns "ext"
	}}}}
@END]]--
PathFileExt = bam_path_ext

--[[@FUNCTION PathPath(str)
	Returns the path of the filename in ^str^.

	{{{{
	PathPath("test/path/file.name.ext") -- Returns "test/path"
	}}}}
@END]]--
PathPath = bam_path_path

-- [TODO: Improve]
-- [TODO: Should be in C]
--[[@FUNCTION
	TODO
@END]]--
function PathRelative(base, str)
	local l = string.len(base)
	if string.sub(s, 0, l) == base then
		return string.sub(s, l+2)
	end
	return s
end

--[[@FUNCTION
	TODO
@END]]--
function PathScriptRelative(s)
	return PathRelative(_bam_path, s)
end

-- [TODO: Should be in C?]
function str_replace(s, pattern, what)
	return string.gsub(s, pattern, function(v) return what end)
end


-- make a table into a string
-- [TODO: Should be in C?]
-- [TODO: Should be removed?]
function tbl_to_str(tbl, prefix, postfix)
	local s = ""
	for index,value in ipairs(tbl) do
		if type(value) == type("") then
			s = s .. prefix .. value .. postfix
		end
	end
	return s
end

function NewTable()
	local t = {}
	t.Add = function(self, ...)
		for i,what in ipairs({...}) do
			table.insert(self, what)
		end
	end
	return t
end

function NewFlagTable()
	local t = {}
	t.Add = function(self, ...)
		for i,what in ipairs({...}) do
			self[what] = 1
		end
	end
	
	t.ToString = function(self)
		local s = ""
		for key,value in pairs(self) do
			if value == 1 then
				s = s .. key .. " "
			end
		end
		return s
	end
	return t
end

function NewPathTable()
	local t = {}
	t.Add = function(self, value)
		table.insert(self, Path(value))
	end
	return t
end

function NewAntiPathTable()
	local t = {}
	t.Add = function(self, value)
		table.insert(self, PathFilename(value))
	end
	return t
end


function default_intermediate_output_func(dir, input, settings)
	if not (dir == "") then
		return Path(dir .. "/" .. PathBase(PathFilename(input)) .. settings.config_ext)
	end
	return PathBase(input) .. settings.config_ext
end

function default_link_output_func(dir, input, settings)
	if not (dir == "") then
		return Path(dir .. "/" .. PathFilename(input) .. settings.config_ext)
	end
	return Path(input) .. settings.config_ext
end

-- copied from the lua-users mailing-list and modified abit 
function table.copy(self, ud_copy_fn)
    ud_copy_fn = ud_copy_fn or function ( ud ) return ud end
    
    local new_table = {}
    for key, value in pairs(self) do
        local new_key
        if(type(key) == 'table') then
            new_key = table.copy(key, ud_copy_fn)
        elseif (type(key) == 'userdata') then
            new_key = ud_copy_fn(key)
        else
            new_key = key
        end

        local new_value
        if(type( value ) == 'table' ) then
            new_value = table.copy(value, ud_copy_fn)
        elseif(type(value) == 'userdata') then
            new_value = ud_copy_fn(value)
        else
            new_value = value
        end

        new_table[new_key] = new_value
    end

     return new_table
end

function table.lock(t)
	local mt = getmetatable(t)
	if not mt then mt = {} end
	mt.__newindex = function(t, key, value)
		error("trying to create key '" .. key .. "' on a locked table")
	end
	setmetatable(t,mt)
end

--[[@GROUP Settings@END]]--

function SetupToolChain(settings, chain)
	settings.cxx.Driver = _G["compile_cxx_"..chain]
	settings.c.Driver = _G["compile_c_"..chain]
	settings.ctest.Driver = _G["compile_c_test_"..chain]
	settings.link.Driver = _G["link_"..chain]
	settings.lib.Driver = _G["lib_"..chain]
	settings.dll.Driver = _G["dll_"..chain]
end


--[[@FUNCTION
	TODO
@END]]--
function NewSettings()
	local s = {}
	
	s.Copy = table.copy
	
	s.debug = 1
	s.objdir = ""
	s.libdir = ""
	s.exedir = ""
	s.config_name = ""
	s.config_ext = ""
	
	--[[
	s.compilers = {"":}
	
	]]--
	
	s.tools = {}

	s.compiler_mappings = {
		["cpp"] = "cxx",
		["c++"] = "cxx",
		["cxx"] = "cxx",
		["cc"] = "cxx",
		["c"] = "c",
		["S"] = "c",
		["m"] = "c"
	}
	
	s.c = {}
	s.c.Driver = nil

	s.cxx = {}
	s.cxx.Driver = nil

	s.ctest = {}
	s.ctest.Driver = nil
	
	s.cc = {}
	s.cc.path = ""
	s.cc.c_compiler = "gcc"
	s.cc.cxx_compiler = "g++"
	s.cc.flags = NewFlagTable()
	s.cc.includes = NewPathTable()
	s.cc.systemincludes = NewTable()
	s.cc.defines = NewTable()
	s.cc.frameworks = NewTable()
	s.cc.output = default_intermediate_output_func
	s.cc.optimize = 0
	s.cc._propagate = function(cc, s) 
		cc.debug = s.debug
	end
	s.cc._propagate(s.cc, s)
	
	s.link = {}
	s.link.Driver = nil
	s.link.path = ""
	s.link.linker = "g++"
	s.link.inputflags = ""
	s.link.flags = NewFlagTable()
	s.link.libs = NewTable()
	s.link.frameworks = NewTable()
	s.link.frameworkpath = NewPathTable()
	s.link.libpath = NewPathTable()
	s.link.extrafiles = NewPathTable()
	s.link.output = default_intermediate_output_func
	s.link._propagate = function(link, s) 
		link.debug = s.debug
	end
	s.link._propagate(s.link, s)
	
	s.lib = {}
	s.lib.Driver = nil
	s.lib.path = ""
	s.lib.flags = NewFlagTable()
	s.lib.output = default_intermediate_output_func
	s.lib._propagate = function(lib, s) 
		lib.debug = s.debug
	end
	s.lib._propagate(s.lib, s)

	s.dll = {}
	s.lib.Driver = nil
	s.dll.path = ""
	s.dll.linker = "g++"
	s.dll.inputflags = ""
	s.dll.flags = NewFlagTable()
	s.dll.libs = NewTable()
	s.dll.frameworks = NewTable()
	s.dll.frameworkpath = NewPathTable()
	s.dll.libpath = NewPathTable()
	s.dll.extrafiles = NewPathTable()
	s.dll.output = default_intermediate_output_func
	s.dll._propagate = function(dll, s) 
		dll.debug = s.debug
	end
	s.dll._propagate(s.dll, s)

	if family == "windows" then
		s.cxx.extension = ".obj"
		s.c.extension = ".obj"
		s.cc.extension = ".obj"
		s.link.extension = ".exe"
		s.lib.extension = ".lib"
		s.dll.extension = ".dll"
	else
		s.cxx.extension = ".o"
		s.c.extension = ".o"
		s.cc.extension = ".o"
		s.link.extension = ""
		s.lib.extension = ".a"
		if platform == "macosx" then
			s.dll.extension = ".dylib"
		else
			s.dll.extension = ".so"	
		end
	end

	-- setup default tool chain
	if family == "windows" then
		SetupToolChain(s, "cl")
	else
		SetupToolChain(s, "gcc")
	end

	-- lock the tables
	table.lock(s)	
	table.lock(s.cc)
	table.lock(s.c)
	table.lock(s.cxx)
	table.lock(s.link)
	table.lock(s.lib)
	table.lock(s.dll)

	return s
end

--[[@GROUP Files and Directories@END]]--

-- Collects files in a directory.
--[[@FUNCTION Collect(...)
	Gathers a set of files using wildcard. Accepts strings and tables
	of strings as input and returns a table of all the files that
	matches A single wildcard * may be used in each string to collect
	a set of files.
	
	Example:
	{{{{
		source_files = Collect('src/*.c", "lib/*.c")
	}}}}
	
	Note. This version collects files, non-recursive.
@END]]--
Collect = bam_collect

--[[@FUNCTION CollectRecursive(...)
	Collects files as the [Collect] but does so recursivly.
@END]]--
CollectRecursive = bam_collectrecursive

--[[@FUNCTION CollectDirs(...)
	Collects directories in the same fashion as [Collect] but returns
	directories instead.
@END]]--
CollectDirs = bam_collectdirs

--[[@FUNCTION CollectDirsRecursive(...)
	Collects directories in the same fashion as [Collect] but does so
	recursivly and returns directories instead.
@END]]--
CollectDirsRecursive = bam_collectdirsrecursive

--[[@GROUP Actions@END]]--

-- Copy -
--[[@FUNCTION
	TODO
@END]]--
function Copy(outputdir, ...)
	local inputs = FlatternTable({...})
	local outputs = {}
	
	-- compile all the files
	for index, inname in ipairs(inputs) do
		output = Path(outputdir .. "/" .. PathFilename(inname))
		input = Path(inname)

		local copy_command = "cp"
		local srcfile = input
		local dstfile = output
		if family == "windows" then
			copy_command = "copy"
			srcfile = str_replace(srcfile, "/", "\\")
			dstfile = str_replace(dstfile, "/", "\\")
		end

		bam_add_job(output,
			"copy " .. input .. " -> " .. output,
			copy_command .. " " .. input .. " " .. output)

		bam_add_dependency(output, input)
		table.insert(outputs, output)
	end
	
	return outputs
end

-- Compiles C and C++ files
--[[@FUNCTION
	TODO
@END]]--
function Compile(settings, ...)
	local inputs = FlatternTable({...})
	local outputs = {}
	
	settings.cc:_propagate(settings);
	
	-- compile all the files
	for index, inname in ipairs(inputs) do

		-- fetch correct compiler
		local ext = PathFileExt(inname)
		local compiler = settings.compiler_mappings[ext]

		if not compiler then
			error("'"..inname.."' has unknown extention '"..ext.."' which there are no compiler for")
		end

		local outname = settings.cc.output(settings.objdir, inname, settings) .. settings.cc.extension
		
		-- add job and run dependencies
		bam_add_job(
			outname,
			compiler .. " " .. inname,
			settings[compiler].Driver(outname, inname, settings.cc)
		)
		
		bam_add_dependency(outname, inname)
		bam_dependency_cpp(inname, settings.cc.includes)
		
		table.insert(outputs, outname)
	end

	-- return the output
	return outputs	
end

--[[@FUNCTION
	TODO
@END]]--
function Link(settings, output, ...)
	local inputs = FlatternTable({...})
	
	settings.link:_propagate(settings);

	output = settings.link.output(settings.exedir, Path(output), settings) .. settings.link.extension
	
	bam_add_job(output, "link " .. output, settings.link.Driver(output, inputs, settings.link))

	-- all the files
	for index, inname in ipairs(inputs) do
		bam_add_dependency(output, inname)
	end
	
	for index, inname in ipairs(settings.link.extrafiles) do
		bam_add_dependency(output, inname)
	end

	return output
end

--[[@FUNCTION
	TODO
@END]]--
function StaticLibrary(settings, output, ...)
	local inputs = FlatternTable({...})

	settings.lib:_propagate(settings);

	output = settings.lib.output(settings.libdir, Path(output), settings) .. settings.lib.extension

	bam_add_job(output, "link " .. output, settings.lib.Driver(output, inputs, settings.lib))

	for index, inname in ipairs(inputs) do
		bam_add_dependency(output, inname)
	end

	return output
end

--[[@FUNCTION
	TODO
@END]]--
function SharedLibrary(settings, output, ...)
	local inputs = FlatternTable({...})

	settings.dll:_propagate(settings);

	output = settings.dll.output(settings.libdir, Path(output), settings) .. settings.dll.extension
	bam_add_job(output, "dll ".. output, settings.dll.Driver(output, inputs, settings.dll))

	for index, inname in ipairs(inputs) do
		bam_add_dependency(output, inname)
	end

	return output
end

--[[@GROUP Targets@END]]--

--[[@FUNCTION Target(filename) (Redundent?)
	Specifies ^filename^ as a target. This target will be include when
	specifying the ^all^ target.
@END]]--
Target = bam_add_target

--[[@FUNCTION DefaultTarget(filename)
	Specifies the default target use build when no targets are
	specified when bam is invoked.
@END]]--
DefaultTarget = bam_default_target

--[[@FUNCTION
	TODO	
@END]]--
function PseudoTarget(name, ...)
	local inputs = FlatternTable({...})
	local name = Path(name)
	bam_add_job(name, "", "")

	-- all the files
	for index, inname in ipairs(inputs) do
		bam_add_dependency(name, inname)
	end

	return name
end

----- gcc/g++ compiler ------
function compile_c_cxx_gcc(label, type, output, input, settings)
	local d = tbl_to_str(settings.defines, "-D", " ")
	local i = tbl_to_str(settings.includes, '-I "', '" ')
	local i = i .. tbl_to_str(settings.systemincludes, '-isystem "', '" ')
	local i = i .. tbl_to_str(settings.frameworks, '-framework ', ' ')
	local f = settings.flags:ToString()
	local path = settings.path
	if settings.debug > 0 then f = f .. "-g " end
	if settings.optimize > 0 then f = f .. "-O2 " end
	local e = path .. type .. ' ' .. f ..'-c ' .. input .. ' -o ' .. output .. ' ' .. d .. i
	return e
	-- return bam_execute(e)
end

function compile_cxx_gcc(output,input,settings)
	return compile_c_cxx_gcc("c++ " .. PathFilename(input), settings.cxx_compiler,output,input,settings)
end

function compile_c_gcc(output,input,settings)
	return compile_c_cxx_gcc("c " .. PathFilename(input), settings.c_compiler,output,input,settings)
end


function compile_c_test_gcc(code, options)
	local f = io.open("_test.c", "w")
	f:write(code)
	f:write("\n")
	f:close()
	local ret = ExecuteSilent("gcc _test.c -o _test " .. options)
	os.remove("_test.c")
	os.remove("_test")
	return ret==0
end

function lib_gcc(output, inputs, settings)
	local e = "ar qc " .. output
	local e = e .. " " .. tbl_to_str(inputs, '', ' ') .. settings.flags:ToString()
	ExecuteSilent("rm -f " .. output) -- TODO: remove this
	return e
end

function dll_gcc(output, inputs, settings)
	local shared_flags = ""

	if platform == "macosx" then
		shared_flags = " -dynamiclib"
	else
		shared_flags = " -shared"
	end

	local e = settings.linker .. shared_flags .. " -o " .. output
	local e = e .. " " .. settings.inputflags .. " " .. tbl_to_str(inputs, '', ' ') 
	local e = e .. tbl_to_str(settings.extrafiles, '', ' ')
	local e = e .. tbl_to_str(settings.libpath, '-L', ' ')
	local e = e .. tbl_to_str(settings.libs, '-l', ' ')
	local e = e .. tbl_to_str(settings.frameworkpath, '-F', ' ')
	local e = e .. tbl_to_str(settings.frameworks, '-framework ', ' ')
	local e = e .. settings.flags:ToString()
	return e
end

function link_gcc(output, inputs, settings)
	local e = settings.linker .. " -o " .. output
	local e = e .. " " .. settings.inputflags .. " " .. tbl_to_str(inputs, '', ' ') 
	local e = e .. tbl_to_str(settings.extrafiles, '', ' ')
	local e = e .. tbl_to_str(settings.libpath, '-L', ' ')
	local e = e .. tbl_to_str(settings.libs, '-l', ' ')
	local e = e .. tbl_to_str(settings.frameworkpath, '-F', ' ')
	local e = e .. tbl_to_str(settings.frameworks, '-framework ', ' ')
	local e = e .. settings.flags:ToString()
	return e
end

----- cl compiler ------
function compile_c_cxx_cl(output, input, settings, label)
	local defs = tbl_to_str(settings.defines, "-D", " ") .. " "
	local incs = tbl_to_str(settings.includes, '-I"', '" ')
	local incs = incs .. tbl_to_str(settings.systemincludes, '-I"', '" ')
	local flags = settings.flags:ToString()
	local path = str_replace(settings.path, "/", "\\")
	if platform =="win32" then
		flags = flags .. " /D \"WIN32\" "
	else
		flags = flags .. " /D \"WIN64\" "
	end
	if settings.debug > 0 then flags = flags .. "/Od /MTd /Zi /D \"_DEBUG\" " end
	if settings.optimize > 0 then flags = flags .. "/Ox /Ot /MT /D \"NDEBUG\" " end
	local exec = path .. 'cl /nologo /D_CRT_SECURE_NO_DEPRECATE /c ' .. flags .. input .. " " .. incs .. defs .. " /Fo" .. output
	return exec
end

function compile_cxx_cl(output,input,settings)
	return compile_c_cxx_cl(output,input,settings,"c++ ")
end

function compile_c_cl(output,input,settings)
	return compile_c_cxx_cl(output,input,settings,"c ")
end

function compile_c_test_cl(code, options)
	local f = io.open("_test.c", "w")
	f:write(code)
	f:write("\n")
	f:close()
	local ret = ExecuteSilent("cl _test.c /Fe_test " .. options)
	os.remove("_test.c")
	os.remove("_test.exe")
	os.remove("_test.obj")
	return ret==0
end

function lib_cl(output, inputs, settings)
	local input =  tbl_to_str(inputs, "", " ")
	local path = str_replace(settings.path, "/", "\\")
	local exec = path .. 'lib /nologo ' .. settings.flags:ToString() .. " /OUT:" .. output .. " " .. input
	return exec
end

function dll_cl(output, inputs, settings)
	local input =  tbl_to_str(inputs, "", " ")
	local flags = settings.flags:ToString()
	local libs  = tbl_to_str(settings.libs, "", " ")
	local libpaths = tbl_to_str(settings.libpath, "/libpath:\"", "\" ")
	local path = str_replace(settings.path, "/", "\\")
	local exec = path .. 'link /nologo /DLL' .. flags .. libpaths .. libs .. " /OUT:" .. output .. " " .. input
	return exec
end

function link_cl(output, inputs, settings)
	local input =  tbl_to_str(inputs, "", " ")
	local flags = settings.flags:ToString()
	local libs  = tbl_to_str(settings.libs, "", ".lib ")
	local libpaths = tbl_to_str(settings.libpath, "/libpath:\"", "\" ")
	local path = str_replace(settings.path, "/", "\\")
	if settings.debug > 0 then flags = flags .. "/DEBUG " end
	local exec = path .. 'link /nologo /incremental:no ' .. flags .. libpaths .. libs .. " /OUT:" .. output .. " " .. input
	return exec
end

compiler_cxx_cl = {
	["compile"] = compile_cxx_cl,
	["test"] = compile_c_test_cl,
}

compiler_c_cl = {
	["compile"] = compile_c_cl,
	["test"] = compile_c_test_cl,
	["link"] = link_cl,
	["lib"] = lib_cl,
	["dll"] = dll_cl,
}

compiler_cxx_gcc = {
	["compile"] = compile_cxx_gcc,
	["test"] = compile_c_test_gcc,
	["link"] = link_gcc,
	["lib"] = lib_gcc,
	["dll"] = dll_gcc,
}

compiler_c_gcc = {
	["compile"] = compile_c_gcc,
	["test"] = compile_c_test_gcc,
	["link"] = link_gcc,
	["lib"] = lib_gcc,
	["dll"] = dll_gcc,
}

function setup_compiler(what_compiler)
	if what_compiler == "gcc" then
		compile_cxx = compile_cxx_gcc
		compile_c = compile_c_gcc
		compile_c_test = compile_c_test_gcc
		link = link_gcc
		lib = lib_gcc
		dll = dll_gcc
	elseif what_compiler == "cl" then
		compile_cxx = compile_cxx_cl
		compile_c = compile_c_cl
		compile_c_test = compile_c_test_cl
		link = link_cl
		lib = lib_cl
		dll = dll_cl
	end
end

--[[@GROUP Configuration@END]]--

--[[@FUNCTION
	TODO
@END]]--
function NewConfig()
	local config = {}
	config.options = {}

	config.Add = function(self, o)
		table.insert(self.options, o)
		self[o.name] = o
	end
	
	config.Print = function(self)
		print("--- CONFIGURATION ---")
		for k,v in pairs(self.options) do
			print(v.name..": "..v:display())
		end
		print("--- --- ---")
	end
	
	config.Save = function(self, filename)
		print("saving configuration to '"..filename.."'")
		local file = io.open(filename, "w")
		
		-- Define a little helper function to save options
		local saver = {}
		saver.file = file
		
		saver.line = function(self, str)
			self.file:write(str .. "\n")
		end
		
		saver.option = function(self, option, name)
			local valuestr = "nil"
			if type(option[name]) == type(0) then
				valuestr = option[name]
			elseif type(option[name]) == type("") then
				valuestr = "'"..option[name].."'"
			elseif type(option[name]) == type(nil) then
				valuestr = "nil"
			else
				error("don't know how to save a value with the type of ".. type(option[name]))
			end
			self.file:write(option.name.."."..name.." = ".. valuestr.."\n")
		end

		-- Save all the options		
		for k,v in pairs(self.options) do
			v:Save(saver)
		end
		file:close()
	end
	
	config.Load = function(self, filename)
		local options_func = loadfile(filename)
		local options_table = {}
		
		if options_func == nil then
			return false
		end

		-- Setup the options tables
		for k,v in pairs(self.options) do
			options_table[v.name] = {}
		end
		setfenv(options_func, options_table)
		
		-- this is to make sure that we get nice error messages when
		-- someone sets an option that isn't valid.
		local mt = {}
		mt.__index = function(t, key)
			local v = rawget(t, key)
			if v ~= nil then return v end
			error("there is no configuration option named '" .. key .. "'")
		end
		setmetatable(options_table, mt)		
		
		-- Process the options
		options_func()
		
		-- Copy the optionss
		for k,v in pairs(self.options) do
			if options_table[v.name] then
				for k2,v2 in pairs(options_table[v.name]) do
					v[k2] = v2
				end
			end
		end
		
		if options_table['compiler'] then
			setup_compiler(self.compiler.value)
		end

		return true
	end

	config.Autodetect = function(self)
		for k,v in pairs(self.options) do
			v:Check()
			print(v.name..": "..v:Display())
			self[v.name] = v
		end
	end
	
	config.Finalize = function(self, filename)
		if _bam_targets[0] == "config" then
			self:Autodetect()
			self:Save(filename)
			os.exit(0)
		end
	
		if not self:Load(filename) then
			print("--- Auto Configuration ---")
			self:Autodetect()
			self:Save(filename)
			print("--- ")
		end
		
		bam_update_globalstamp(filename)
	end
	
	return config
end

--- SilentExecute
function _execute_silent_win(command) return os.execute(command .. " >nul 2>&1") end
function _execute_silent_unix(command) return os.execute(command .. " >/dev/null 2>/dev/null") end

--[[@FUNCTION ExecuteSilent(command)
	TODO
@END]]--

if family == "windows" then
	ExecuteSilent = _execute_silent_win
else
	ExecuteSilent = _execute_silent_unix
end

-- Helper functions --------------------------------------
function DefaultOptionDisplay(option)
	if not option.value then return "no" end
	if option.value == 1 then return "yes" end
	return option.value
end

function MakeOption(name, value, check, save, display)
	local o = {}
	o.name = name
	o.value = value
	o.Check = check
	o.Save = save
	
	o.Display = display
	if o.Display == nil then o.Display = DefaultOptionDisplay end
	return o
end


-- Test Compile C --------------------------------------
function OptTestCompileC(name, source)
	local check = function(option)
		option.value = nil
		if compile_c_test("int main(){return 0;}", "-fstack-protector -fstack-protector-all") then
			option.value = 1
		end
	end
	
	local save = function(option, output)
		output:option(option, "value")
	end
	
	local o = MakeOption(name, 0, check, save)
	o.source = source
	return o
end

-- Find Compiler --------------------------------------
--[[@FUNCTION
	TODO
@END]]--
function OptFindCompiler()
	local check = function(option)
		if ExecuteSilent("g++ -v") == 0 then
			option.value = "gcc"
		elseif ExecuteSilent("cl") == 0 then
			option.value = "cl"
		else
			error("no c/c++ compiler found")
		end
		
		setup_compiler(option.value)
	end
	
	local save = function(option, output)
		output:option(option, "value")
	end
	
	return MakeOption("compiler", "none", check, save)
end

-- Find Library --------------------------------------
--[[@FUNCTION
	TODO
@END]]--
function OptFindLibrary(name, header, library, required)
	local check = function(option)
		option.value = nil
		
		local function check_compile_include(filename, paths)
			if compile_c_test("#include <" .. filename .. ">\nint main(){return 0;}", "") then
				return ""
			end

			for k,v in pairs(paths) do
				if compile_c_test("#include <" .. filename .. ">\nint main(){return 0;}", "-I"..v) then
					return v
				end
			end
			
			return nil
		end
		
		option.include_path = check_compile_include(option.header, {})
		if option.include_path == nil then
			if option.required then
				print(name.." library not found and is required")
				error("required library not found")
			end
		else
			option.value = 1
			if option.include_path == "" then
				option.include_path = nil
			end
		end
	end
	
	local save = function(option, output)
		output:option(option, "value")
		output:option(option, "include_path")
	end
	
	local display = function(option)
		if option.value then
			if option.include_path then
				return option.include_path
			else
				return "(in system path)"
			end
		else
			if option.required then
				return "not found (required)"
			else
				return "not found (optional)"
			end
		end
	end
	
	local o = MakeOption(name, 0, check, save, display)
	o.include_path = nil
	o.header = header
	o.required = required
	return o
end

---

--[[@GROUP Modules@END]]--

--[[@FUNCTION
	TODO
@END]]--
function Import(modname)
	local paths = {""}
	local chunk = nil

	s = os.getenv("BAM_PACKAGES")
	if s then
		for w in string.gmatch(s, "[^:]*") do
			if string.len(w) > 0 then
				table.insert(paths, w)
			end
		end
	end
	
	for k,v in pairs(paths) do
		chunk = loadfile(modname)
		if chunk then
			local current = _bam_modulefilename
			_bam_modulefilename = modname
			chunk()
			_bam_modulefilename = current
			return
		end
	end

	error(modname .. " not found")
end


--[[@FUNCTION
	TODO
@END]]--
function ModuleFilename()
	return _bam_modulefilename
end



--[[@GROUP Job and Dependencies@END]]--

--[[@FUNCTION AddJob(output, label, command)
	Adds a job to be done. The ^output^ string specifies the file that
	will be created by the command line specified in ^command^ string.
	The ^label^ is printed out before ^command^ is runned.
@END]]--
AddJob = bam_add_job

--[[@FUNCTION AddDependency(filename, depfilename)
	Specifies a dependency of a file. The file specified in the
	^depfilename^ is a dependency of ^filename^.
@END]]--
AddDependency = bam_add_dependency

